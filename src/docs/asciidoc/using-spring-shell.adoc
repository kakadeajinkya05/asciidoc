= Spring Shell Manual
Doc Writer <akakade@qualys.com>
2014-09-09
:revnumber: {project-version}
:example-caption!:
:starter-artifactId: spring-shell-starter

== Using Spring Shell

=== Getting Started
To see what Spring Shell has to offer, let's write a trivial shell application that
has a simple command to add two numbers together.

==== Let's Write a Simple Boot App
Starting with version 2, Spring Shell has been rewritten from the ground up with various
enhancements in mind, one of which is easy integration with Spring Boot, although it is
not a strong requirement.
For the purpose of this tutorial, let's create a simple Boot application, for example
using http://start.spring.io. This minimal application only depends on `spring-boot-starter`
and configures the `spring-boot-maven-plugin`, generating an executable Ã¼ber-jar:

[source, xml]
----
...
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ...
----

==== Adding a Dependency on Spring Shell
The easiest way to get going with Spring Shell is to depend on the `{starter-artifactId}` artifact.
This comes with everything one needs to use Spring Shell and plays nicely with Boot,
configuring only the necessary beans as needed:

[source, xml, subs=attributes+]
----
...
<dependency>
    <groupId>org.springframework.shell</groupId>
    <artifactId>{starter-artifactId}</artifactId>
    <version>{project-version}</version>
</dependency>
...
----

[CAUTION]
====
Given that Spring Shell will kick in and start the REPL by virtue of this dependency being present,
you'll need to either build skipping tests (`-DskipTests`) throughout this tutorial or remove the sample integration test
that was generated by http://start.spring.io. If you don't do so, the integration test will create
the Spring `ApplicationContext` and, depending on your build tool, will stay stuck in the eval loop or crash with a NPE.
====

==== Your first command
It's time to add our first command. Create a new class (name it however you want) and
annotate it with `@ShellComponent` (a variation of `@Component` that is used to restrict
the set of classes that are scanned for candidate commands).

Then, create an `add` method that takes two ints (`a` and `b`) and returns their sum. Annotate it
with `@ShellMethod` and provide a description of the command in the annotation (the only piece of
information that is required):

[source, java]
----
package com.example.demo;

import org.springframework.shell.standard.ShellMethod;
import org.springframework.shell.standard.ShellComponent;

@ShellComponent
public class MyCommands {

    @ShellMethod("Add two integers together.")
    public int add(int a, int b) {
        return a + b;
    }
}
----

==== Let's Give It a Ride!
Build the application and run the generated jar, like so;
[source, bash]
----
./mvnw clean install -DskipTests
[...]

java -jar target/demo-0.0.1-SNAPSHOT.jar
----

You'll be greeted by the following screen (the banner comes from Spring Boot, and can be customized
http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-banner[as usual]):

[source]
----

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.6.RELEASE)

shell:>
----

Below is a yellow `shell:>` prompt that invites you to type commands. Type `add 1 2` then kbd:[ENTER] and admire the magic!

[source, bash]
----
shell:>add 1 2
3
----

Try to play with the shell (hint: there is a `help` command) and when you're done, type `exit` kbd:[ENTER].

The rest of this document delves deeper into the whole Spring Shell programming model.

=== Writing your own Commands

The way Spring Shell decides to turn a method into an actual shell command is entirely pluggable
(see xref:extending-spring-shell[]), but as of Spring Shell 2.x, the recommended way to write commands
is to use the new API described in this section (the so-called _standard_ API).

Using the _standard_ API, methods on beans will be turned into executable commands provided that

* the bean class bears the `@ShellComponent` annotation. This is used to restrict the set of beans that
are considered.
* the method bears the `@ShellMethod` annotation.

[TIP]
====
The `@ShellComponent` is a stereotype annotation itself meta-annotated with `@Component`. As such, it
can be used in addition to the filtering mechanism to also _declare_ beans (_e.g._ using `@ComponentScan`).

The name of the created bean can be customized using the `value` attribute of the annotation.
====

==== It's all about Documentation!

The only required attribute of the `@ShellMethod` annotation is its `value` attribute, which should be used
to write a short, one-sentence, description of what the command does. This is important so that your users can
get consistent help about your commands without having to leave the shell (see xref:help-command[]).

[NOTE]
====
The description of your command should be short, one or two sentences only. For better consistency, it is
recommended that it starts with a capital letter and ends with a dot.
====

==== Customizing the Command Name(s)

By default, there is no need to specify the _key_ for your command (_i.e._ the word(s) that should be used
to invoke it in the shell). The name of the method will be used as the command key, turning camelCase names into
dashed, gnu-style, names (that is, `sayHello()` will become `say-hello`).

It is possible, however, to explicitly set the command key, using the `key` attribute of the annotation, like so:
[source, java]
----
	@ShellMethod(value = "Add numbers.", key = "sum")
	public int add(int a, int b) {
		return a + b;
	}

----

[NOTE]
====
The `key` attribute accepts multiple values.
If you set multiple keys for a single method, then the command will be registered using those different aliases.
====

[TIP]
====
The command key can contain pretty much any character, including spaces. When coming up with names though,
keep in mind that consistency is often appreciated by users (_i.e._ avoid mixing dashed-names with spaced names, _etc._)
====
